/**
 * Base API
 * Base API Definition.
 *
 * OpenAPI spec version: 0.316.0
 * Contact: hambardzumyan.albert@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Transaction } from '../model/transaction';
import { TransactionChangePending } from '../model/transactionChangePending';
import { TransactionChangePendingAndState } from '../model/transactionChangePendingAndState';
import { TransactionChangePendingStatus } from '../model/transactionChangePendingStatus';
import { TransactionCostDataBase } from '../model/transactionCostDataBase';
import { TransactionCostDataCostOfGood } from '../model/transactionCostDataCostOfGood';
import { TransactionCostDataCostOfGoodBase } from '../model/transactionCostDataCostOfGoodBase';
import { TransactionCostDataPopulated } from '../model/transactionCostDataPopulated';
import { TransactionCreatePayload } from '../model/transactionCreatePayload';
import { TransactionMilestone } from '../model/transactionMilestone';
import { TransactionMilestonesPopulated } from '../model/transactionMilestonesPopulated';
import { TransactionStateReviewUpdatePayload } from '../model/transactionStateReviewUpdatePayload';
import { TransactionStateUpdatePayload } from '../model/transactionStateUpdatePayload';
import { TransactionTally } from '../model/transactionTally';
import { TransactionTallyPopulated } from '../model/transactionTallyPopulated';
import { TransactionTallyUnit } from '../model/transactionTallyUnit';
import { TransactionTallyUnitContract } from '../model/transactionTallyUnitContract';
import { TransactionTallyUnitCreatePayload } from '../model/transactionTallyUnitCreatePayload';
import { TransactionTrackingDataBase } from '../model/transactionTrackingDataBase';
import { TransactionTrackingDataBuyerDataCrmDataPayload } from '../model/transactionTrackingDataBuyerDataCrmDataPayload';
import { TransactionTrackingDataBuyerDataOnlineData } from '../model/transactionTrackingDataBuyerDataOnlineData';
import { TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated } from '../model/transactionTrackingDataBuyerDataOnlineOrCrmDataPopulated';
import { TransactionTrackingDataPopulated } from '../model/transactionTrackingDataPopulated';
import { TransactionTrackingDataPrivateData } from '../model/transactionTrackingDataPrivateData';
import { TransactionTrackingDataSellerDataCrmDataPayload } from '../model/transactionTrackingDataSellerDataCrmDataPayload';
import { TransactionTrackingDataSellerDataOnlineData } from '../model/transactionTrackingDataSellerDataOnlineData';
import { TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated } from '../model/transactionTrackingDataSellerDataOnlineOrCrmDataPopulated';
import { TransactionTrackingDataTransportMethodUpdatePayload } from '../model/transactionTrackingDataTransportMethodUpdatePayload';
import { TransactionTransactionalJournalEntry } from '../model/transactionTransactionalJournalEntry';
import { TransactionTransactionalJournalPopulated } from '../model/transactionTransactionalJournalPopulated';
import { TransportMethodEmbeddedInTrackingData } from '../model/transportMethodEmbeddedInTrackingData';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class TransactionsService {

    protected basePath = 'http://base-api-development.buychain.tech/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add transaction.
     * Add transaction. Default access - resource:owner.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransaction(payload: TransactionCreatePayload, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public addTransaction(payload: TransactionCreatePayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public addTransaction(payload: TransactionCreatePayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public addTransaction(payload: TransactionCreatePayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Transaction>(`${this.basePath}/transactions`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction cost-data cogp.
     * Add transaction cost-data cogp. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE, REVIEW].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionCostDataCogp(id: string, payload: TransactionCostDataCostOfGood, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataCostOfGood>;
    public addTransactionCostDataCogp(id: string, payload: TransactionCostDataCostOfGood, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataCostOfGood>>;
    public addTransactionCostDataCogp(id: string, payload: TransactionCostDataCostOfGood, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataCostOfGood>>;
    public addTransactionCostDataCogp(id: string, payload: TransactionCostDataCostOfGood, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionCostDataCogp.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionCostDataCogp.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionCostDataCostOfGood>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data/cogp`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction cost-data cogs.
     * Add transaction cost-data cogs. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE, REVIEW].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionCostDataCogs(id: string, payload: TransactionCostDataCostOfGood, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataCostOfGood>;
    public addTransactionCostDataCogs(id: string, payload: TransactionCostDataCostOfGood, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataCostOfGood>>;
    public addTransactionCostDataCogs(id: string, payload: TransactionCostDataCostOfGood, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataCostOfGood>>;
    public addTransactionCostDataCogs(id: string, payload: TransactionCostDataCostOfGood, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionCostDataCogs.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionCostDataCogs.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionCostDataCostOfGood>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data/cogs`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction milestone.
     * Add transaction milestone. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionMilestone(id: string, payload: TransactionMilestone, observe?: 'body', reportProgress?: boolean): Observable<TransactionMilestone>;
    public addTransactionMilestone(id: string, payload: TransactionMilestone, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionMilestone>>;
    public addTransactionMilestone(id: string, payload: TransactionMilestone, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionMilestone>>;
    public addTransactionMilestone(id: string, payload: TransactionMilestone, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionMilestone.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionMilestone.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionMilestone>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/milestones`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction state change-pending.
     * Add transaction state change-pending. Default access - resource:owner. - Supports transition from CONFIRMED to one of [CANCEL, MODIFY_TRANSPORT]. - Supports transition from IN_TRANSIT to one of [CANCEL, MODIFY_TRANSPORT]. - The transaction should be offline.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionStateChangePending(id: string, payload: TransactionChangePending, observe?: 'body', reportProgress?: boolean): Observable<TransactionChangePendingAndState>;
    public addTransactionStateChangePending(id: string, payload: TransactionChangePending, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionChangePendingAndState>>;
    public addTransactionStateChangePending(id: string, payload: TransactionChangePending, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionChangePendingAndState>>;
    public addTransactionStateChangePending(id: string, payload: TransactionChangePending, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionStateChangePending.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionStateChangePending.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionChangePendingAndState>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/state/change-pending`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction tally unit.
     * Add transaction tally unit. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE]. - Should not be a duplicate unit in transaction tally. - The product should not be allocated. - The offline product state should be DRAFT. - The online product state should be one of [ON_ORDER, IN_TRANSIT, ON_HAND]. - The shipFrom facility should be the same for all the units in transaction tally.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionTallyUnit(id: string, payload: TransactionTallyUnitCreatePayload, observe?: 'body', reportProgress?: boolean): Observable<TransactionTallyUnit>;
    public addTransactionTallyUnit(id: string, payload: TransactionTallyUnitCreatePayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTallyUnit>>;
    public addTransactionTallyUnit(id: string, payload: TransactionTallyUnitCreatePayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTallyUnit>>;
    public addTransactionTallyUnit(id: string, payload: TransactionTallyUnitCreatePayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionTallyUnit.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionTallyUnit.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionTallyUnit>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction tally unit contract.
     * Add transaction tally unit contract. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE]. - The transaction tally unit should not have a contract.
     * @param id Transaction id - hex, ref Transactions.
     * @param unitId Transaction tally unit id - hex, ref Transactions.tally.units.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'body', reportProgress?: boolean): Observable<TransactionTallyUnitContract>;
    public addTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTallyUnitContract>>;
    public addTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTallyUnitContract>>;
    public addTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionTallyUnitContract.');
        }

        if (unitId === null || unitId === undefined) {
            throw new Error('Required parameter unitId was null or undefined when calling addTransactionTallyUnitContract.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionTallyUnitContract.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionTallyUnitContract>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units/${encodeURIComponent(String(unitId))}/contract`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add transaction transactional-journal.
     * Add transaction transactional-journal. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTransactionTransactionalJournal(id: string, payload: TransactionTransactionalJournalEntry, observe?: 'body', reportProgress?: boolean): Observable<TransactionTransactionalJournalEntry>;
    public addTransactionTransactionalJournal(id: string, payload: TransactionTransactionalJournalEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTransactionalJournalEntry>>;
    public addTransactionTransactionalJournal(id: string, payload: TransactionTransactionalJournalEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTransactionalJournalEntry>>;
    public addTransactionTransactionalJournal(id: string, payload: TransactionTransactionalJournalEntry, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTransactionTransactionalJournal.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling addTransactionTransactionalJournal.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransactionTransactionalJournalEntry>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/transactional-journal`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete transaction.
     * Get transaction. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE]. - The draft products would be deleted (offline).
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTransaction(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTransaction(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTransaction(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTransaction(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTransaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete transaction tally unit.
     * Delete transaction tally unit. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param unitId Transaction tally unit id - hex, ref Transactions.tally.units.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTransactionTally(id: string, unitId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTransactionTally(id: string, unitId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTransactionTally(id: string, unitId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTransactionTally(id: string, unitId: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTransactionTally.');
        }

        if (unitId === null || unitId === undefined) {
            throw new Error('Required parameter unitId was null or undefined when calling deleteTransactionTally.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units/${encodeURIComponent(String(unitId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete transaction tally unit contract.
     * Delete transaction tally unit contract. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE]. - The transaction tally unit should have a contract.
     * @param id Transaction id - hex, ref Transactions.
     * @param unitId Transaction tally unit id - hex, ref Transactions.tally.units.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTransactionTallyContract(id: string, unitId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTransactionTallyContract(id: string, unitId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTransactionTallyContract(id: string, unitId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTransactionTallyContract(id: string, unitId: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTransactionTallyContract.');
        }

        if (unitId === null || unitId === undefined) {
            throw new Error('Required parameter unitId was null or undefined when calling deleteTransactionTallyContract.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units/${encodeURIComponent(String(unitId))}/contract`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction cost-data.
     * Get transaction cost-data. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionCostData(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataPopulated>;
    public getTransactionCostData(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataPopulated>>;
    public getTransactionCostData(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataPopulated>>;
    public getTransactionCostData(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionCostData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionCostDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction milestones.
     * Get transaction milestones. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionMilestones(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionMilestonesPopulated>;
    public getTransactionMilestones(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionMilestonesPopulated>>;
    public getTransactionMilestones(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionMilestonesPopulated>>;
    public getTransactionMilestones(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionMilestones.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionMilestonesPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/milestones`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction tally.
     * Get transaction tally. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionTally(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionTallyPopulated>;
    public getTransactionTally(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTallyPopulated>>;
    public getTransactionTally(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTallyPopulated>>;
    public getTransactionTally(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionTally.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionTallyPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction tracking-data.
     * Get transaction tracking-data. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionTrackingData(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataPopulated>;
    public getTransactionTrackingData(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataPopulated>>;
    public getTransactionTrackingData(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataPopulated>>;
    public getTransactionTrackingData(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionTrackingData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionTrackingDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction tracking-data private-data.
     * Get transaction tracking-data private-data. Default access - resource:owner. - Returns the buyer or seller private data based on who the requester is.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionTrackingDataPrivateData(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataPrivateData>;
    public getTransactionTrackingDataPrivateData(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataPrivateData>>;
    public getTransactionTrackingDataPrivateData(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataPrivateData>>;
    public getTransactionTrackingDataPrivateData(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionTrackingDataPrivateData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionTrackingDataPrivateData>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/private-data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get transaction transactional-journal.
     * Get transaction transactional-journal. Default access - resource:owner. - The requester would be added into transactionalJournalAllRead if transactionalJournal is not empty.
     * @param id Transaction id - hex, ref Transactions.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionTransactionalJournal(id: string, observe?: 'body', reportProgress?: boolean): Observable<TransactionTransactionalJournalPopulated>;
    public getTransactionTransactionalJournal(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTransactionalJournalPopulated>>;
    public getTransactionTransactionalJournal(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTransactionalJournalPopulated>>;
    public getTransactionTransactionalJournal(id: string, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionTransactionalJournal.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TransactionTransactionalJournalPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/transactional-journal`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction cost-data.
     * Update transaction cost-data. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionCostData(id: string, payload: TransactionCostDataBase, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataBase>;
    public updateTransactionCostData(id: string, payload: TransactionCostDataBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataBase>>;
    public updateTransactionCostData(id: string, payload: TransactionCostDataBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataBase>>;
    public updateTransactionCostData(id: string, payload: TransactionCostDataBase, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionCostData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionCostData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionCostDataBase>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction cost-data cogp.
     * Update transaction cost-data cogp. Default access - resource:owner. - Buyer only. - The transaction state should be one of [DRAFT, QUOTE, REVIEW].
     * @param id Transaction id - hex, ref Transactions.
     * @param cogId Transaction cost-data cogp id - hex, ref Transactions.costData.cogp.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionCostDataCogp(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataCostOfGood>;
    public updateTransactionCostDataCogp(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataCostOfGood>>;
    public updateTransactionCostDataCogp(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataCostOfGood>>;
    public updateTransactionCostDataCogp(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionCostDataCogp.');
        }

        if (cogId === null || cogId === undefined) {
            throw new Error('Required parameter cogId was null or undefined when calling updateTransactionCostDataCogp.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionCostDataCogp.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionCostDataCostOfGood>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data/cogp/${encodeURIComponent(String(cogId))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction cost-data cogs.
     * Update transaction cost-data cogs. Default access - resource:owner. - Seller only. - The transaction state should be one of [DRAFT, QUOTE, REVIEW].
     * @param id Transaction id - hex, ref Transactions.
     * @param cogId Transaction cost-data cogs id - hex, ref Transactions.costData.cogs.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionCostDataCogs(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'body', reportProgress?: boolean): Observable<TransactionCostDataCostOfGood>;
    public updateTransactionCostDataCogs(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionCostDataCostOfGood>>;
    public updateTransactionCostDataCogs(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionCostDataCostOfGood>>;
    public updateTransactionCostDataCogs(id: string, cogId: string, payload: TransactionCostDataCostOfGoodBase, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionCostDataCogs.');
        }

        if (cogId === null || cogId === undefined) {
            throw new Error('Required parameter cogId was null or undefined when calling updateTransactionCostDataCogs.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionCostDataCogs.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionCostDataCostOfGood>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/cost-data/cogs/${encodeURIComponent(String(cogId))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction state.
     * Update transaction state. Default access - resource:owner. - The buying company should be set for QUOTE transition.
     * @param id Transaction id - hex, ref Transactions.
     * @param state
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionState(id: string, state: TransactionStateUpdatePayload, observe?: 'body', reportProgress?: boolean): Observable<TransactionStateUpdatePayload>;
    public updateTransactionState(id: string, state: TransactionStateUpdatePayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionStateUpdatePayload>>;
    public updateTransactionState(id: string, state: TransactionStateUpdatePayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionStateUpdatePayload>>;
    public updateTransactionState(id: string, state: TransactionStateUpdatePayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionState.');
        }

        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateTransactionState.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TransactionStateUpdatePayload>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/state`,
            state,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction state change-pending.
     * Update transaction state change-pending. Default access - resource:owner. - The transaction state should be CHANGE_PENDING. - The transaction should be offline. - Cancel - forbidden if tally units are allocated in down chain. - Modify-transport - the shipToLocation is not allowed to modify if at least one tally units is allocated in down chain. - Modify-transport - the costBasis of tally line-items would be recalculated on transportTerm or shippingCost modification. - Modify-transport - the shipWeekEstimate of tally line-items would be updated on estimatedShipDate modification. - Modify-transport - the ownerName and ownerId of tally line-items would be updated on onlineData.shipToContact modification. - Modify-transport - the shipFromShortName and shipFromId (onlineData) of tally line-items would be updated on onlineData.shipToLocation modification.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionStateChangePending(id: string, payload: TransactionChangePendingStatus, observe?: 'body', reportProgress?: boolean): Observable<TransactionChangePendingAndState>;
    public updateTransactionStateChangePending(id: string, payload: TransactionChangePendingStatus, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionChangePendingAndState>>;
    public updateTransactionStateChangePending(id: string, payload: TransactionChangePendingStatus, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionChangePendingAndState>>;
    public updateTransactionStateChangePending(id: string, payload: TransactionChangePendingStatus, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionStateChangePending.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionStateChangePending.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TransactionChangePendingAndState>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/state/change-pending`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction state review.
     * Update transaction state review. Default access - resource:owner. - Tally products would be deallocated on quote transition. - Double confirmation would be prevented. - The state of tally units should be ON-HAND for CONFIRMED transition. - The tally products should not have outstanding purchase contract for CONFIRMED transition.
     * @param id Transaction id - hex, ref Transactions.
     * @param state
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionStateReview(id: string, state: TransactionStateReviewUpdatePayload, observe?: 'body', reportProgress?: boolean): Observable<TransactionStateReviewUpdatePayload>;
    public updateTransactionStateReview(id: string, state: TransactionStateReviewUpdatePayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionStateReviewUpdatePayload>>;
    public updateTransactionStateReview(id: string, state: TransactionStateReviewUpdatePayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionStateReviewUpdatePayload>>;
    public updateTransactionStateReview(id: string, state: TransactionStateReviewUpdatePayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionStateReview.');
        }

        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateTransactionStateReview.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TransactionStateReviewUpdatePayload>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/state/review`,
            state,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tally.
     * Update transaction tally. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTally(id: string, payload: TransactionTally, observe?: 'body', reportProgress?: boolean): Observable<TransactionTally>;
    public updateTransactionTally(id: string, payload: TransactionTally, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTally>>;
    public updateTransactionTally(id: string, payload: TransactionTally, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTally>>;
    public updateTransactionTally(id: string, payload: TransactionTally, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTally.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTally.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTally>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tally unit.
     * Update transaction tally unit. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param unitId Transaction tally unit id - hex, ref Transactions.tally.units.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTallyUnit(id: string, unitId: string, payload: TransactionTallyUnit, observe?: 'body', reportProgress?: boolean): Observable<TransactionTallyUnit>;
    public updateTransactionTallyUnit(id: string, unitId: string, payload: TransactionTallyUnit, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTallyUnit>>;
    public updateTransactionTallyUnit(id: string, unitId: string, payload: TransactionTallyUnit, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTallyUnit>>;
    public updateTransactionTallyUnit(id: string, unitId: string, payload: TransactionTallyUnit, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTallyUnit.');
        }

        if (unitId === null || unitId === undefined) {
            throw new Error('Required parameter unitId was null or undefined when calling updateTransactionTallyUnit.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTallyUnit.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTallyUnit>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units/${encodeURIComponent(String(unitId))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tally unit contract.
     * Update transaction tally unit contract. Default access - resource:owner. - The transaction state should be one of [DRAFT, QUOTE]. - The transaction tally unit should have a contract.
     * @param id Transaction id - hex, ref Transactions.
     * @param unitId Transaction tally unit id - hex, ref Transactions.tally.units.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'body', reportProgress?: boolean): Observable<TransactionTallyUnitContract>;
    public updateTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTallyUnitContract>>;
    public updateTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTallyUnitContract>>;
    public updateTransactionTallyUnitContract(id: string, unitId: string, payload: TransactionTallyUnitContract, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTallyUnitContract.');
        }

        if (unitId === null || unitId === undefined) {
            throw new Error('Required parameter unitId was null or undefined when calling updateTransactionTallyUnitContract.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTallyUnitContract.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTallyUnitContract>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tally/units/${encodeURIComponent(String(unitId))}/contract`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data.
     * Update transaction tracking-data. Default access - resource:owner. - Any of [estimatedShipDate, transportTerm] is supported only if the state is one of [DRAFT, QUOTE]. - The transport-method &amp; shipping-cost will be reset on transport-term update.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingData(id: string, payload: TransactionTrackingDataBase, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataPopulated>;
    public updateTransactionTrackingData(id: string, payload: TransactionTrackingDataBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataPopulated>>;
    public updateTransactionTrackingData(id: string, payload: TransactionTrackingDataBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataPopulated>>;
    public updateTransactionTrackingData(id: string, payload: TransactionTrackingDataBase, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data buyer-data crm-data.
     * Update transaction tracking-data buyer-data crm-data. Default access - resource:owner. - Seller only. - The transaction state should be one of [DRAFT, QUOTE]. - The autofillBackwards is allowed in QUOTE state. - The transportMethod of tracking-data will be reset on shipTo field update.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataBuyerDataCrmData(id: string, payload: TransactionTrackingDataBuyerDataCrmDataPayload, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>;
    public updateTransactionTrackingDataBuyerDataCrmData(id: string, payload: TransactionTrackingDataBuyerDataCrmDataPayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataBuyerDataCrmData(id: string, payload: TransactionTrackingDataBuyerDataCrmDataPayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataBuyerDataCrmData(id: string, payload: TransactionTrackingDataBuyerDataCrmDataPayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataBuyerDataCrmData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataBuyerDataCrmData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/buyer-data/crm-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data buyer-data online-data.
     * Update transaction tracking-data buyer-data online-data. Default access - resource:owner. - Buyer only. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataBuyerDataOnlineData(id: string, payload: TransactionTrackingDataBuyerDataOnlineData, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>;
    public updateTransactionTrackingDataBuyerDataOnlineData(id: string, payload: TransactionTrackingDataBuyerDataOnlineData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataBuyerDataOnlineData(id: string, payload: TransactionTrackingDataBuyerDataOnlineData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataBuyerDataOnlineData(id: string, payload: TransactionTrackingDataBuyerDataOnlineData, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataBuyerDataOnlineData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataBuyerDataOnlineData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataBuyerDataOnlineOrCrmDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/buyer-data/online-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data private-data.
     * Update transaction tracking-data private-data. Default access - resource:owner.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataPrivateData(id: string, payload: TransactionTrackingDataPrivateData, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataPrivateData>;
    public updateTransactionTrackingDataPrivateData(id: string, payload: TransactionTrackingDataPrivateData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataPrivateData>>;
    public updateTransactionTrackingDataPrivateData(id: string, payload: TransactionTrackingDataPrivateData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataPrivateData>>;
    public updateTransactionTrackingDataPrivateData(id: string, payload: TransactionTrackingDataPrivateData, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataPrivateData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataPrivateData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataPrivateData>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/private-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data seller-data crm-data.
     * Update transaction tracking-data seller-data crm-data. Default access - resource:owner. - Buyer only. - The transaction state should be one of [DRAFT, QUOTE].
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataSellerDataCrmData(id: string, payload: TransactionTrackingDataSellerDataCrmDataPayload, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>;
    public updateTransactionTrackingDataSellerDataCrmData(id: string, payload: TransactionTrackingDataSellerDataCrmDataPayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataSellerDataCrmData(id: string, payload: TransactionTrackingDataSellerDataCrmDataPayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataSellerDataCrmData(id: string, payload: TransactionTrackingDataSellerDataCrmDataPayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataSellerDataCrmData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataSellerDataCrmData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/seller-data/crm-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data seller-data online-data.
     * Update transaction tracking-data seller-data online-data. Default access - resource:owner. - Seller only. - The transaction state should be one of [DRAFT, QUOTE]. - The designated seller should be from the same company.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataSellerDataOnlineData(id: string, payload: TransactionTrackingDataSellerDataOnlineData, observe?: 'body', reportProgress?: boolean): Observable<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>;
    public updateTransactionTrackingDataSellerDataOnlineData(id: string, payload: TransactionTrackingDataSellerDataOnlineData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataSellerDataOnlineData(id: string, payload: TransactionTrackingDataSellerDataOnlineData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>>;
    public updateTransactionTrackingDataSellerDataOnlineData(id: string, payload: TransactionTrackingDataSellerDataOnlineData, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataSellerDataOnlineData.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataSellerDataOnlineData.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransactionTrackingDataSellerDataOnlineOrCrmDataPopulated>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/seller-data/online-data`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update transaction tracking-data transport-method.
     * Update transaction tracking-data transport-method. Default access - resource:owner. - Any of [carrier, railRestriction, railCarNumber] is supported only if the type is RAIL. - Any of [type, carrier, railRestriction, cost] is supported only if the state is one of [DRAFT, QUOTE]. - Will reset rail specific fields if type has been changes to other than RAIL.
     * @param id Transaction id - hex, ref Transactions.
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTransactionTrackingDataTransportMethod(id: string, payload: TransactionTrackingDataTransportMethodUpdatePayload, observe?: 'body', reportProgress?: boolean): Observable<TransportMethodEmbeddedInTrackingData>;
    public updateTransactionTrackingDataTransportMethod(id: string, payload: TransactionTrackingDataTransportMethodUpdatePayload, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransportMethodEmbeddedInTrackingData>>;
    public updateTransactionTrackingDataTransportMethod(id: string, payload: TransactionTrackingDataTransportMethodUpdatePayload, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransportMethodEmbeddedInTrackingData>>;
    public updateTransactionTrackingDataTransportMethod(id: string, payload: TransactionTrackingDataTransportMethodUpdatePayload, observe: any = 'body', reportProgress = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransactionTrackingDataTransportMethod.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateTransactionTrackingDataTransportMethod.');
        }

        let headers = this.defaultHeaders;

        // authentication (AccessToken) required
        if (this.configuration.apiKeys["authorization"]) {
            headers = headers.set('authorization', this.configuration.apiKeys["authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TransportMethodEmbeddedInTrackingData>(`${this.basePath}/transactions/${encodeURIComponent(String(id))}/tracking-data/transport-method`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
